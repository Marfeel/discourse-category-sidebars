<script>
  // Check each .custom-sidebar-section[data-sidebar-name] exists on .sidebar-section-wrapper[data-section-name]
  // if not exist clone .custom-sidebar-section[data-sidebar-name] from #main-outlet using mutationobserver
  function updateCustomSidebar() {
    const sidebarSections = document.querySelectorAll(
      ".sidebar-section-wrapper[data-section-name]"
    );
    sidebarSections.forEach((section) => {
      const sidebarName = section.dataset.sectionName;
      const customSidebar = document.querySelector(
        `.sidebar-section-wrapper .custom-sidebar-section[data-sidebar-name="${sidebarName}"]`
      );
      if (!customSidebar) {
        const mainOutlet = document.querySelector("#main-outlet");
        const customSidebarClone = mainOutlet.querySelector(
          `.custom-sidebar-section[data-sidebar-name="${sidebarName}"]`
        );
        if (customSidebarClone) {
          const clonedSidebar = customSidebarClone.cloneNode(true);
          section.appendChild(clonedSidebar);
        }
      }
    });
  }

  // TODO: Remove when Discourse 3.5.0+
  // Fix for sidebar sections not being collapsible on mobile
  // Fixed in: https://github.com/discourse/discourse/commit/0abc33c5a25a5ab3535c678e6c5e03412fdd8b8a (3.5.0-beta8)
  function fixMobileCollapsibleHeaders() {
    const isMobile =
      window.innerWidth <= 768 ||
      document.body.classList.contains("mobile-view");
    if (!isMobile) return;

    const sidebarHeaders = document.querySelectorAll(
      ".sidebar-section-header button, .sidebar-section-header"
    );

    sidebarHeaders.forEach((header) => {
      if (header.hasAttribute("data-mobile-collapsible-fixed")) return;

      const headerText = header.textContent || "";

      const isCustomSection =
        headerText.toLowerCase().includes("product") ||
        headerText.toLowerCase().includes("implementation") ||
        headerText.toLowerCase().includes("guides") ||
        headerText.toLowerCase().includes("general");

      if (isCustomSection) {
        header.setAttribute("data-mobile-collapsible-fixed", "true");

        if (header.tagName === "BUTTON") {
          if (!header.hasAttribute("aria-expanded")) {
            header.setAttribute("aria-expanded", "true");
          }

          header.addEventListener("click", (e) => {
            const isExpanded = header.getAttribute("aria-expanded") === "true";
            header.setAttribute("aria-expanded", (!isExpanded).toString());

            const parent = header.closest(
              '.sidebar-section-wrapper, [class*="section"]'
            );
            if (parent) {
              const content = parent.querySelector(
                ".custom-sidebar-section, .sidebar-section-content"
              );
              if (content) {
                content.style.display = isExpanded ? "none" : "";
              }
            }
          });
        } else {
          header.setAttribute("role", "button");
          header.setAttribute("aria-expanded", "true");
          header.style.cursor = "pointer";

          header.addEventListener("click", (e) => {
            e.preventDefault();
            const isExpanded = header.getAttribute("aria-expanded") === "true";
            header.setAttribute("aria-expanded", (!isExpanded).toString());

            const parent = header.closest(
              '.sidebar-section-wrapper, [class*="section"]'
            );
            if (parent) {
              const content = parent.querySelector(
                ".custom-sidebar-section, .sidebar-section-content"
              );
              if (content) {
                content.style.display = isExpanded ? "none" : "";
              }
            }
          });
        }
      }
    });
  }

  const fixedObserver = new MutationObserver(() => {
    updateCustomSidebar();
    fixMobileCollapsibleHeaders();
  });

  const mainOutletSidebars = document.querySelector("body");
  if (mainOutletSidebars) {
    fixedObserver.observe(mainOutletSidebars, {
      childList: true,
      subtree: true,
    });

    window.addEventListener("beforeunload", () => {
      fixedObserver.disconnect();
    });
  }
</script>
